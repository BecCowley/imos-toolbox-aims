function sample_data = hoboU2xParse( filename, mode )
%hoboU22Parse Parses a .txt data file from a Hobo U22-001 temperature logger.
%
% This function is able to read in a .txt data file produced via an export
% option of the Hobo HOBOware software. It reads specific instrument header 
% format and makes use of a lower level function readHoboCsv to convert the data. 
% The files consist of two sections:
%
%   - processed header  - header information generated by HOBOware software.
%                         Typically first 1-2 lines.
%   - data              - Rows of comma seperated data.
%
% This function reads in the header sections, and delegates to the two file
% specific sub functions to process the data.
%
%
% HOBOware export settings
% Export file type: Text (.txt or .csv)
% Export table data column separator: Semicolon (;)
% Include line number column: OFF
% Include plot title in header: OFF
% Always show fractional seconds: ON
% Separate date and time into two columns: ON
% No quotes or commas in headings, properties in parentheses: OFF
% Include logger serial and number: ON
% Include sensor serial number or label if available: ON
% Date format: Y M D
% Date separator: Slash (/)
% Time format: 24-Hour
% Positive number format: 1,234.56
% Negative number format: -123
%
% Inputs:
%   filename    - cell array of files to import (only one supported).
%   mode        - Toolbox data type mode ('profile' or 'timeSeries').
%
% Outputs:
%   sample_data - Struct containing sample data.
%
% Code based on SBE37SMParse.m
%
% Author:       Simon Spagnol <s.spagnol@aims.gov.au>
% Contributor:  Guillaume Galibert <guillaume.galibert@utas.edu.au>

%
% Copyright (c) 2009, eMarine Information Infrastructure (eMII) and Integrated
% Marine Observing System (IMOS).
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%     * Redistributions of source code must retain the above copyright notice,
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the eMII/IMOS nor the names of its contributors
%       may be used to endorse or promote products derived from this software
%       without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%
error(nargchk(1,2,nargin));

if ~iscellstr(filename)
    error('filename must be a cell array of strings');
end

% only one file supported currently
filename = filename{1};

% read in every line of header in the file, then big read of data
procHeaderLines = {};
try
    fid = fopen(filename, 'rt');
    fileContent = textscan(fid, '%s', 'Delimiter', '', 'Whitespace', '');
    fclose(fid);
    fileContent = fileContent{1};
    
    % Example HOBO csv files with export settings outlined above
% "Date";"Time, GMT+08:00";"Temp, °C (LGR S/N: 10382197, SEN S/N: 10382197)";"Coupler Detached (LGR S/N: 10382197)";"Coupler Attached (LGR S/N: 10382197)";"Host Connected (LGR S/N: 10382197)";"End Of File (LGR S/N: 10382197)"
% 15/04/06;19:00:00.0;24.002;Logged;;;
% 15/04/06;19:01:00.0;24.002;;;;
% 15/04/06;19:02:00.0;24.026;;;;

    % for procHeaderLines look for # at start or a " (but not at start
    % of line, because have had some strange characters appearing before
    % the "
    ii = 1;
    line = strtrim(fileContent{ii});
    while ~isempty(regexp(line,'^#|\"'))
        if ~isempty(line)
            procHeaderLines{end+1} = line;
            ii=ii+1;
            line = strtrim(fileContent{ii});
        else
            ii=ii+1;
            line = strtrim(fileContent{ii});
        end
    end

    dataLines = fileContent(ii:end);
    % have had one case where there where extra non-ascii characters before
    % the first column name
    procHeaderLines = regexprep(procHeaderLines, '^(.*?)"','"');
    % make assumption that only on header line will have the Date etc
    % column descriptor
    dLine=find(~cellfun(@isempty,regexp(procHeaderLines,'Date')));
    if strfind(dLine, ';')
        colSep = ';';
    else
        colSep = ',';
    end
    % match text between double quotes
    colNames=strtrim(regexp(procHeaderLines{dLine},'\"(.*?)\"', 'match'));
    ncolumns=numel(colNames);
    % find column index for various data, some will be used to index entire
    % column others just into column name
    colStr = {'idxSerial', 'idxDate', 'idxTime', 'idxTemp', 'idxPres', 'idxDatetime'};
    colRegStr = {'LGR S\/N\:', '"Date(?!(\sTime))', '"Time', '"Temp', '"Abs Pres', '"Date Time'};
    column_indices = struct;
    max_column_index = 0;
    for k = 1:numel(colRegStr)
        tkn = regexp(colNames, colRegStr{k});
        ind = ~cellfun('isempty', tkn);
        v = colStr{k};
        if any(ind)
            column_indices.(v) = find(ind, 1);
            max_column_index = max(max_column_index, column_indices.(v));
        else
            column_indices.(v) = 0;
        end
    end
    
    if column_indices.idxPres
        procHeader.instrument_model='U20-001';
    else
        procHeader.instrument_model='U22-001';
    end
    procHeader.instrument_serial_no = regexp(colNames{column_indices.idxSerial},'LGR S\/N: (\d+)','tokens');
    procHeader.instrument_serial_no = strtrim(char(procHeader.instrument_serial_no{1}));

% Not sure if the 'Time' column header always has a GMT offset, so not using this
% just yet.
%     regStr='GMT([+-])(\d{2}):(\d{2})';
%     tks=regexp(colNames{colInd.iTime},regStr,'tokens');
%     tMultiplier=+1;
%     procHeader.utc_offset_hours = str2num(tks{1}{1}) + str2num(tks{1}{2})/60
%     if strcmp(tks{1}{1},'-')
%         procHeader.utc_offset_hours=-procHeader.utc_offset_hours;
%     end

    fid = fopen(filename, 'rt');
    dataLines = textscan(fid,[repmat('%s',[1 max_column_index]) '%*s'], 'Delimiter', colSep, 'HeaderLines', ii-1);
    fclose(fid);
    
    is_empty = false(size(dataLines{1}));
    for k = 1:numel(dataLines)
       is_empty = is_empty | [cellfun(@isempty, dataLines{k})];
    end
    for k = 1:numel(dataLines)
       dataLines{k}(is_empty) = [];
    end
    
    % have fractional seconds
    have_seperate_date_time_columns = column_indices.idxDate & column_indices.idxTime;
    if have_seperate_date_time_columns
        vidxTime = 'idxTime';
    else
        vidxTime = 'idxDatetime';
    end
    if strfind(dataLines{column_indices.(vidxTime)}{1}, '.')
        timeFmt = 'HH:MM:SS.FFF';
    else
        timeFmt = 'HH:MM:SS';
    end
    
    % accidentally exported in 12h time format
    if contains(dataLines{column_indices.(vidxTime)}{1}, {'AM', 'PM'})
        timeFmt = [timeFmt , ' AM'];
    end
    
    % extract datetime strings
    if have_seperate_date_time_columns
        datestrings = strcat(dataLines{column_indices.idxDate},'T',dataLines{column_indices.idxTime});
        datetime_sep = 'T';
    elseif isfield(column_indices, 'idxDatetime')
        datestrings = dataLines{column_indices.idxDatetime};
        datetime_sep = ' ';
    else
        error('Unknown date/time format.');
    end
    
    try
        datetimeFmt = ['yy/mm/dd' datetime_sep timeFmt];
        data.TIME = datenum(datestrings, datetimeFmt);
    catch
        try
            datetimeFmt = ['dd/mm/yy' datetime_sep timeFmt];
            data.TIME = datenum(datestrings, datetimeFmt);
            warning('Had to assume dd/mm/yy date format instead of expected yy/mm/dd format.');
        catch
            errormsg('Unknown data format, tried yy/mm/dd and dd/mm/yy.');
        end
    end
    
    comment.TIME = 'TIME';
    
    data.TEMP = str2double(dataLines{column_indices.idxTemp});
    comment.TEMP = '';
    
    if ~isempty(column_indices.idxPres)
        data.PRES = str2double(dataLines{column_indices.idxPres});
        comment.PRES = '';
        scale = 1; % scale pressure units to dbar
        tkns = regexpi(colNames{column_indices.idxPres} ,'Abs Pres,\s+(.+)\s+\(', 'tokens');
        switch upper(tkns{1}{1})
            case 'MBAR'
                scale = 0.01;
            case 'PSI'
                scale = 0.6894757;
            case 'KPA'
                scale = 0.1;
            case 'PA'
                scale = 0.0001;
            case 'IN HG'
                scale = 0.3386389;
            case 'MM HG'
                scale = 0.0133322387415;
        end
        data.PRES = data.PRES * scale;
    end
    clear('dataLines');
    clear('fileContent');
    
catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
end

% read in the raw instrument header
%procHeader = parseProcessedHeader( procHeaderLines, dataHeaderLine);

% create sample data struct,
% and copy all the data in
sample_data = struct;
sample_data.meta.instrument_make='HOBO';
sample_data.toolbox_input_file  = filename;
sample_data.meta.procHeader     = procHeader;
%sample_data.utc_offset_hours = procHeader.utc_offset_hours;

if isfield(procHeader, 'instrument_model')
    sample_data.meta.instrument_model = procHeader.instrument_model;
else
    sample_data.meta.instrument_model = 'Unknown';
end

% if isfield(procHeader, 'instrument_firmware')
%     sample_data.meta.instrument_firmware = procHeader.instrument_firmware;
% else
%     sample_data.meta.instrument_firmware = '';
% end

if isfield(procHeader, 'instrument_serial_no')
    sample_data.meta.instrument_serial_no = procHeader.instrument_serial_no;
else
    sample_data.meta.instrument_serial_no = '';
end

time = data.TIME;

if isfield(procHeader, 'sampleInterval')
    sample_data.meta.instrument_sample_interval = procHeader.sampleInterval;
else
    sample_data.meta.instrument_sample_interval = median(diff(time*24*3600));
end

sample_data.dimensions = {};
sample_data.variables  = {};

% generate time data from header information
sample_data.dimensions{1}.name          = 'TIME';
sample_data.dimensions{1}.typeCastFunc  = str2func(netcdf3ToMatlabType(imosParameters(sample_data.dimensions{1}.name, 'type')));
sample_data.dimensions{1}.data          = sample_data.dimensions{1}.typeCastFunc(time);

sample_data.variables{1}.dimensions     = [];
sample_data.variables{1}.name           = 'LATITUDE';
sample_data.variables{1}.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{1}.name, 'type')));
sample_data.variables{1}.data           = sample_data.variables{1}.typeCastFunc(NaN);
sample_data.variables{2}.dimensions     = [];
sample_data.variables{2}.name           = 'LONGITUDE';
sample_data.variables{2}.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{2}.name, 'type')));
sample_data.variables{2}.data           = sample_data.variables{2}.typeCastFunc(NaN);
sample_data.variables{3}.dimensions     = [];
sample_data.variables{3}.name           = 'NOMINAL_DEPTH';
sample_data.variables{3}.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{3}.name, 'type')));
sample_data.variables{3}.data           = sample_data.variables{3}.typeCastFunc(NaN);

% scan through the list of parameters that were read
% from the file, and create a variable for each
vars = fieldnames(data);
coordinates = 'TIME LATITUDE LONGITUDE NOMINAL_DEPTH';
if any(strcmpi('DEPTH', vars))
    coordinates = [coordinates ' DEPTH'];
end
for k = 1:length(vars)
    
    if strncmp('TIME', vars{k}, 4), continue; end
    
    % dimensions definition must stay in this order : T, Z, Y, X, others;
    % to be CF compliant
    sample_data.variables{end+1}.dimensions     = 1;
    sample_data.variables{end  }.name           = vars{k};
    sample_data.variables{end  }.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
    sample_data.variables{end  }.data           = sample_data.variables{end}.typeCastFunc(data.(vars{k}));
    if ~strcmpi(vars{k}, 'DEPTH')
        sample_data.variables{end  }.coordinates    = coordinates;
    end
    sample_data.variables{end  }.comment        = comment.(vars{k});
end

end

function header = parseProcessedHeader(headerLines, colInd)
%PARSEPROCESSEDHEADER Parses the data contained in the header of csv file
% produced by Logger Vue software. This includes the column layout of the 
% data in the .csv file. 
%
% Inputs:
%   headerLines - Cell array of strings, the lines in the processed header 
%                 section.
%   colInd - index of various elements in header line.
%
% Outputs:
%   header      - struct containing information that was contained in the
%                 processed header section.
%

% example header lines from instrument
%
% "Date";"Time, GMT+08:00";"Temp, °C (LGR S/N: 10382197, SEN S/N: 10382197)";"Coupler Detached (LGR S/N: 10382197)";"Coupler Attached (LGR S/N: 10382197)";"Host Connected (LGR S/N: 10382197)";"End Of File (LGR S/N: 10382197)"

  header = struct;

  sourceExpr = '^Source Device: ([\w-]+)-(\d+)$';
  startExpr  = '^Study Start Time: (.+)';
  stopExpr   = '^Study Stop Time: (.+)';
  sampleExpr = '^Sample Interval: (\d+):(\d+):(\d+)';
  
  header.nHeaderLines=numel(headerLines)+1;
  header.columns = regexp(dataHeaderLine,',','split');

  for k = 1:length(headerLines)
      
      % try source expr
      tkns = regexp(headerLines{k}, sourceExpr, 'tokens');
      if ~isempty(tkns)
          header.instrument_model     = tkns{1}{1};
          header.instrument_serial_no = tkns{1}{2};
          continue;
      end
      
      % then try startTime expr
      tkns = regexp(headerLines{k}, startExpr, 'tokens');
      if ~isempty(tkns)
          header.startTime = datenum(tkns{1}{1});
          continue;
      end
      
      % then try stopTime expr
      tkns = regexp(headerLines{k}, stopExpr, 'tokens');
      if ~isempty(tkns)
          header.stopTime = datenum(tkns{1}{1});
          continue;
      end
      
      % then try sample interval expr, return result in seconds
      tkns = regexp(headerLines{k}, sampleExpr, 'tokens');
      if ~isempty(tkns)
          header.sampleInterval = str2double(tkns{1}{1})*3600 + str2double(tkns{1}{2})*60 + str2double(tkns{1}{3});
          continue;
      end
      
  end
end