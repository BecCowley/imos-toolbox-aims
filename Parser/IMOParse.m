function sample_data = IMOParse( filename, mode )
%IMOParse Parses a .log data file from an IMO sensor
%
% This function is able to read in a .log data file produced by extracting
% out sensor log from DL3 .text file.
%
%   - processed header  - header information generated by Logger Vue software.
%                         Typically first 5 lines.
%   - data              - Rows of comma seperated data.
%
% This function reads in the header sections, and delegates to the two file
% specific sub functions to process the data.
%
% Inputs:
%   filename    - cell array of files to import (only one supported).
%   mode        - Toolbox data type mode.
%
% Outputs:
%   sample_data - Struct containing sample data.
%
% Code based on SBE37SMParse.m
%
% Each data record starts with a Port Identifier. These Ports correspond
% to the Port numbering on the bulkhead connectors, with the exception
% of Port 0, which is reserved for the DL3’s additional internal sensor
% suite. Each data record contains the date (DD/MM/YYYY), time
% (HH:MM:SS:mil) and the external sensor’s data record encapsulated
% by ‘< >’ characters.
%
% The DL3 (Port 0) data format is as follows:
% Device Id, Serial Number, Vin Counts, Pressure Counts, Temp Counts, Vin
% (V), Depth (m), Temperature (C)
% example
% Port0: 07/04/2017,08:28:46.000,<IMO-DL3,0028,1023,3238,690,11.5,-0.3,28.4>
%
% IMO-NTU output:
% Sensor Type, Serial Number, Date, Time, dark_counts, measured_counts, NTU, tilt, led_temp, checksum
% Message ID $IMNTU
% Serial # 0012
% Date 21022016 ddmmyyyy
% Time 150327.000 hhmmss.sss
% Dark Counts 2122 Counts ADC Digital Counts (LED off)
% Meas Counts 2260 Counts ADC Digital Counts (LED on)
% NTU 1.796 NTU Calibrated NTU Output
% Tilt 66.3 Degrees ddd.d
% LED Temp 26.8125 Degrees Celsius xx.xxxx
% Checksum *7C
% example
% <$IMNTU,0031,30032017,115136.803,1997,1957,0.149,179.0,29.8125*7D>
%
% IMO-MS8
% NOTE: ONLY engineering/cal output MS8EN (output mode 1/cal), not MS8RW
% Sensor Type, Serial Number, Date, Time, (ch irradiance) x 8, Tilt, Int Temp
% PAR units: mW/cm^2
% example
% <$MS8EN,0026,27/03/2017,14:13:55.000,0.141,0.126,0.310,0.173,-0.019,0.048,0.030,0.063,86.8,27.625>
%
% The checksum field consists of a '*' and two hex digits representing
% an 8 bit exclusive OR of all characters between, but not including,
% the '$' and '*'.
%
% The sensor only .log format will only contain sensor data (without <>)
%
% Author:       Simon Spagnol <s.spagnol@aims.gov.au>
% Contributor:  Guillaume Galibert <guillaume.galibert@utas.edu.au>

%
% Copyright (c) 2017, Australian Ocean Data Network (AODN) and Integrated
% Marine Observing System (IMOS).
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%     * Redistributions of source code must retain the above copyright notice,
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the AODN/IMOS nor the names of its contributors
%       may be used to endorse or promote products derived from this software
%       without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%
narginchk(1,2);

if ~iscellstr(filename)
    error('filename must be a cell array of strings');
end

% only one file supported currently
filename = filename{1};

% read in every line of header in the file, then big read of data
procHeaderLines = {};
try
    fid = fopen(filename, 'rt');
    line = strtrim(fgetl(fid));
    frewind(fid);
    if strcmpi(line, 'In-situ Marine Optics')
        % most likely a .TXT format DL3 file
        [procHeader, data, units, comment] = readIMODL3(fid);
    elseif strcmp(line(1), '$') || strfind(line, 'IMO-DL3')
        % most likely a .log format MS8/NTU/PAR file
        [procHeader, data, units, comment] = readIMOsensor(fid);
    else
        error('Unknown IMO format');
    end
    
    fclose(fid);
    
catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
end

procHeader.toolbox_input_file = filename;

% create sample data struct,
% and copy all the data in
sample_data = struct;

sample_data.toolbox_input_file  = filename;
sample_data.meta.featureType    = mode;
sample_data.meta.procHeader     = procHeader;

sample_data.meta.instrument_make = 'IMO';
if isfield(procHeader, 'instrument_model')
    sample_data.meta.instrument_model = procHeader.instrument_model;
else
    sample_data.meta.instrument_model = 'IMO Unknown';
end

if isfield(procHeader, 'instrument_firmware')
    sample_data.meta.instrument_firmware = procHeader.instrument_firmware;
else
    sample_data.meta.instrument_firmware = '';
end

if isfield(procHeader, 'instrument_serial_num')
    sample_data.meta.instrument_serial_no = procHeader.instrument_serial_num;
elseif isfield(procHeader, 'instrument_serial_number')
    sample_data.meta.instrument_serial_no = procHeader.instrument_serial_number;
else
    sample_data.meta.instrument_serial_no = '';
end

time = data.TIME;

if isfield(procHeader, 'instrument_sample_interval')
    sample_data.meta.instrument_sample_interval = procHeader.instrument_sample_interval;
else
    sample_data.meta.instrument_sample_interval = median(diff(time*24*3600));
end

if isfield(procHeader, 'instrument_sampling_mode') && strcmp(procHeader.instrument_sampling_mode, 'BURST')
    sample_data.meta.instrument_burst_interval = procHeader.instrument_burst_interval;
    sample_data.meta.instrument_burst_duration = procHeader.instrument_burst_duration;
end

sample_data.dimensions = {};
sample_data.variables  = {};

% generate time data from header information
sample_data.dimensions{1}.name          = 'TIME';
sample_data.dimensions{1}.typeCastFunc  = str2func(netcdf3ToMatlabType(imosParameters(sample_data.dimensions{1}.name, 'type')));
sample_data.dimensions{1}.data          = sample_data.dimensions{1}.typeCastFunc(time);

sample_data.variables{end+1}.name           = 'TIMESERIES';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(1);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'LATITUDE';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'LONGITUDE';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'NOMINAL_DEPTH';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];

% scan through the list of parameters that were read
% from the file, and create a variable for each
vars = fieldnames(data);
coordinates = 'TIME LATITUDE LONGITUDE NOMINAL_DEPTH';
for k = 1:length(vars)
    
    if strncmp('TIME', vars{k}, 4), continue; end
    
    % dimensions definition must stay in this order : T, Z, Y, X, others;
    % to be CF compliant
    sample_data.variables{end+1}.dimensions     = 1;
    sample_data.variables{end  }.name           = vars{k};
    sample_data.variables{end  }.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
    sample_data.variables{end  }.data           = sample_data.variables{end}.typeCastFunc(data.(vars{k}));
    sample_data.variables{end  }.coordinates    = coordinates;
    if isfield(comment, vars{k})
        sample_data.variables{end  }.comment        = comment.(vars{k});
    end
    if isfield(units, vars{k})
        sample_data.variables{end  }.units        = units.(vars{k});
    end
end

end

%%
function [header, data, units, comment] = readIMODL3(fid)
% parse IMO DL3 TXT file

% unlikely to be handled.

header = struct;
data = struct;
units = struct;
comment = struct;

try
    frewind(fid);
    allLines = textscan(fid, '%s', 'Delimiter', '\n');
    allLines = allLines{1};
catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
end

tf = contains(allLines, '-------------------------------');
ind = find(tf);
if isempty(ind)
    error('IMO DL3 TXT format not handled.')
end
header.headerlines = allLines(1:ind);
dataLines = allLines(ind+1:end);

ind_conf = find(contains(header.headerlines, '---------CONFIGURATION---------'));

% instrument info
instrument_info = header.headerlines(1:ind_conf-1);

% assume ordering in instrument_info are fixed
header.instrument_make = strtrim(instrument_info{1});
header.instrument_comment = strtrim(instrument_info{2});
tokens = regexp(instrument_info{3}, '([\w-]*)\s+\(SN:(\d+)\)', 'tokens');
header.instrument_model = tokens{1}{1};
header.instrument_serial_number = tokens{1}{2};

ind = find(contains(instrument_info, 'FIRMWARE'));
token = regexp(instrument_info{ind}, 'FIRMWARE:\s+(\w*)', 'tokens');
header.firmware = cell2str(token{1});

% instrument configuration
ind_cal = find(contains(header.headerlines, '---CALIBRATION CONFIGURATION---'));
instrument_configuration = header.headerlines(ind_conf+1:ind_cal-1);

ind = find(contains(instrument_configuration, 'IN-WATER'));
if isempty(ind)
    header.instrument_mode = 'WATER_MODE';
else
    header.instrument_mode = 'AIR_MODE';
end

%DETECTOR OUTPUT = IRR
ind = find(contains(instrument_configuration, 'DETECTOR OUTPUT ='));
token = regexp(instrument_configuration{ind}, 'DETECTOR OUTPUT =\s+(\w*)', 'tokens');
% if not IRR or RAD then error as cannot handle RAW
if ~(strcmp(token{1}{1}, 'IRR') | strcmp(token{1}{1}, 'RAD'))
    error('Cannot handle DETECTOR OUTPUT = RAW.');
end

ind = find(contains(instrument_configuration, 'SAMPLERATE ='));
token = regexp(instrument_configuration{ind}, 'SAMPLERATE =\s+(\w*)', 'tokens');
header.instrument_sampling_rate = 1.0/str2num(token{1}{1}); % hertz -> seconds

isBurstSampling = false;
isContinuousSampling = false;

% SAMPLERATE = 1
% SAMPLING MODE = BURSTMODE
% BURST SAMPLES = 10
% BURST INTERVAL = 15
% BURST PROGRAM = 1

ind = find(contains(instrument_configuration, 'SAMPLING MODE ='));
token = regexp(instrument_configuration{ind}, 'SAMPLING MODE =\s+(\w*)', 'tokens');
if contains(instrument_configuration{ind}, 'BURST')
    isBurstSampling = true;
    header.instrument_sampling_mode = 'BURST';
    
    ind = find(contains(instrument_configuration, 'BURST SAMPLES ='));
    token = regexp(instrument_configuration{ind}, 'BURST SAMPLES =\s+(\d*)', 'tokens');
    header.instrument_burst_duration = str2num(token{1}{1}) * header.instrument_sampling_rate; %seconds
    
    ind = find(contains(instrument_configuration, 'BURST INTERVAL ='));
    token = regexp(instrument_configuration{ind}, 'BURST INTERVAL =\s+(\d*)', 'tokens');
    header.instrument_burst_interval = str2num(token{1}{1}) * 60; %minutes -> seconds
elseif contains(instrument_configuration{ind}, 'CONTINUOUS')
    isContinuousSampling = true;
    header.instrument_sampling_mode = 'CONTINUOUS';
else
    error('Unknown sampling mode.');
end

ind = find(contains(instrument_configuration, 'SAMPLING MODE ='));
if ~isempty(ind)
    isBurstSampling = true;
end

ind = find(contains(instrument_configuration, 'TIMEZONE ='));
token = regexp(instrument_configuration{ind}, 'TIMEZONE =\s+([+-]?(?:\d+\.?\d*|\d*\.\d+))', 'tokens');
header.instrument_utc_offset = str2num(token{1}{1}); %hours

ind = find(contains(instrument_configuration, 'WIPE INTERVAL ='));
token = regexp(instrument_configuration{ind}, 'WIPE INTERVAL =\s+(\d*)', 'tokens');
header.instrument_wiper_interval = str2num(token{1}{1}) * 3600; %hours -> seconds

% instrument calibration
instrument_calibration = header.headerlines(ind_cal+1:length(header.headerlines)-1);

ind = find(contains(instrument_calibration, 'WAVELENGTHS ='));
token = regexp(instrument_calibration{ind}, 'WAVELENGTHS\s+=\s+\[(\S+)\]', 'tokens');
header.instrument_wavelengths = token{1}{1};

% data
splitData = split(dataLines, ',');
[nrows, ncols] = size(splitData);

if ncols == 18 % no TEMP or DEPTH sensor
    indDate = 3;
    indTime = 4;
    indWiper = 5;
    indBatt = 6;
    indTilt = 7;
    indInternalTemp = 8;
    indPar = 9;
    indCh1 = 10;
    indCh9 = 18;
elseif ncols == 20
    indDate = 3;
    indTime = 4;
    indWiper = 5;
    indBatt = 6;
    indDepth = 7;
    indTemp = 8;
    indTilt = 9;
    indInternalTemp = 10;
    indPar = 11;
    indCh1 = 12;
    indCh9 = 20;
else
    error('Unknown data layout.')
end

data.TIME = datenum([char(splitData(:,indDate)) char(splitData(:,indTime))],'dd/mm/yyyyHH:MM:SS.FFF');
data.TIME = data.TIME - header.instrument_utc_offset/24.0;
comment.TIME = 'TIME';

data.WIPER_STATUS = str2double(splitData(:,indWiper));
comment.WIPER_STATUS = 'Wiper Position (0 for open and 1 for closed)';

data.BAT_VOLT = str2double(splitData(:,indBatt));
comment.BAT_VOLT = 'Input Voltage (V)';
units.BAT_VOLT = 'volts';

if ncols == 20
    data.DEPTH = str2double(splitData(:,indDepth));
    units.DEPTH = 'm';
    data.TEMP = str2double(splitData(:,indTemp));
    units.TEMP =  'Degrees Celsius';
end

data.TILT = str2double(splitData(:,indTilt));
units.TILT = 'degrees';

data.INTERNAL_TEMP = str2double(splitData(:,indInternalTemp));
comment.INTERNAL_TEMP = 'Internal instrument temperature';
units.INTERNAL_TEMP = 'Degrees Celsius';

% internally calculated PAR
data.PAR = str2double(splitData(:,indPar)); % umole m^-2 s^-1
comment.PAR = 'PAR calculated from integrated irradiance from 400 to 700nm';
units.PAR = 'umole m-2 s-1';

wavelengths = split(header.instrument_wavelengths, ',');
for i=indCh1:indCh9
    vName = ['CH' num2str(i-indCh1+1)];
    data.(vName) = str2double(splitData(:,i));
    units.(vName) =  'uW cm-2'; %?
    comments.(vName) = [wavelengths{i-indCh1+1} 'nm'];
end

% PAR calculated
% put all channel data into one array
lambda = str2double(wavelengths);
nChannels = length(lambda);
nSamples = size(data.CH1,1);
tmpData = zeros([nSamples, nChannels]);
for i = 1:nChannels
    vName = ['CH' num2str(i)];
    tmpData(:,i)= data.(vName);
end

% Convert MS8EN/MS9 uW/cm^2/nm data to W/m^2/nm
tmpData = tmpData ./ 100.0;

PAR = calcPAR(tmpData, lambda);

end

%%
function PAR = calcPAR(data, lambda)
%CALCPAR Calculate PAR by integrating irradiance over 400 to 700nm
% Requires data (nSamples, nWavelenghts) in W m^-2 nm^-1
% lambda (sample wavelenghts) in nm

% for MS8EN
% lambda = [425, 455, 485, 515, 555, 615, 660, 695];
% for MS9 about
% lambda = [410.4, 438.6, 491.1, 511.8, 550.2, 589.8, 635.6, 659.4, 700.6]

lambda = lambda(:);

PAR = struct;

% derive PAR from MS8EN sampled wavelengths using method from
% Wojciech Klonowski @ Insitu Marine Optics
nChannels = length(lambda);
nSamples = size(data,1);

% new spacing between 400 - 700 nm.
newLambda = 400:1:700;
nNewChannels = size(newLambda,2);

% IMO: convert to photons per second by dividing by h*c / lambda.
% factor 1e-9 converts nm to m.
% IMO: convert to microMoles per second by dividing by
% Avogadro's constant * 1e6
% IMO: interpolate multispectral micromoles per sec to high res 1nm
% %IDL% micromolespersec_ipol=interpol(micromolespersec,lambda,new_lambda)
% IMO: now calculate the integral of micromolespersec_ipol. I would
% think MATLAB has some sort of INT_TABULATED or Simpson or
% Trapezoidal functions.
% %IDL% PAR=int_tabulated(new_lambda,micromolespersec_ipol)

h = 6.62607015e-34; % plancks constant, J s
c = 2.99792458e+08; % speed of light, m s^-1
avo = 6.02214076e+23; % Avogadro's constant, mol^-1
denom = h*c*avo; % J m mol-1

data = (data .*  lambda' .* 1e-9) ./ denom; % mol s^-1

newData=nan([nSamples, nNewChannels]);
for i = 1:nSamples
    newData(i,:) = interp1(lambda, data(i, :), newLambda, 'linear', 'extrap');
end

data = nan([nSamples, 1]);
for i = 1:nSamples
    data(i) = trapz(newLambda, newData(i,:));
end

% data -> moles m^-2 s^-1
% data * 1e6 -> umoles m^-2 s^-1
PAR.data = data * 1e6;
PAR.name = 'PAR';
PAR.comment = 'PAR calculated by integrating irradiance over 400 to 700nm.';
PAR.units = 'umole m-2 s-1';

end

%%
function [header, data, units, comment] = readIMOsensor(fid)
% parse IMO sensor log file. Can only be one sensor per file.

header = struct;
data = struct;
comment = struct;
units = struct;

% IMO-MS8
% Sensor Type, Serial Number, Date, Time, Counts, PAR, Tilt, Int Temp
line = strtrim(fgetl(fid));
frewind(fid);

cols = split(line, ',');
nCols = numel(cols) - 4; % number of data columns
serialStr = char(cols(2));

instStr = '';
sensorVariableNames = {};
if strfind(line, '$IMNTU')
    instStr = 'IMNTU';
    formatStr = ['$' instStr];
    sensorVariableNames = {'DATE', 'TIME', 'COUNTS_DARK', 'COUNTS_NTU', 'TURB', 'TILT', 'LED_TEMP'};
    sensorVariableUnits = {'1', '1', 'count', 'count', '1', 'degree', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', ''};
    header.instrument_model = 'IMNTU';
elseif strfind(line, '$MS8EN')
    instStr = 'MS8EN';
    formatStr = ['$' instStr];
    sensorVariableNames = {'DATE', 'TIME', 'CH1', 'CH2', 'CH3', 'CH4', 'CH5', 'CH6', 'CH7', 'CH8','TILT', 'INTERNAL_TEMP'};
    sensorVariableUnits = {'1', '1', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'degree', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', '' ,  '', '', '', '', ''};
    header.instrument_model = 'MS8EN';
elseif strfind(line, 'IMO-DL3')
    instStr = 'IMO-DL3';
    formatStr = instStr;
    %Device Id, Serial Number, Vin Counts, Pressure Counts, Temp Counts, Vin (V), Depth (m), Temperature (C)
    sensorVariableNames = {'DATE', 'TIME', 'COUNTS_VIN', 'COUNTS_PRES', 'COUNTS_TEMP', 'VIN', 'DEPTH', 'TEMP'};
    sensorVariableUnits = {'1', '1', 'count', 'count', 'count', 'V', 'm', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', '', ''};
    header.instrument_model = 'DL3';
else
    error('Uknown IMO sensor');
end

header.instrument_serial_num = char(cols(2));
formatStr = [formatStr ',%*d'];

iChecksum = strfind(line, '*');
if iChecksum
    formatStr = [formatStr ',%[^*]*%s'];
else
    formatStr = [formatStr ',%s'];
end

frewind(fid);
allLines = textscan(fid,formatStr);
dataLines = allLines{1};
if iChecksum
    checksums = uint8(hex2dec(allLines{2}));
    
    cs = zeros([numel(checksums) 1], 'uint8');
    for i=1:numel(checksums)
        line = [instStr ',' serialStr ',' char(dataLines{i})];
        for j = 1:length(line)
            cs(i) = bitxor(cs(i), uint8(line(j)));
        end
    end
    iGoodChecksums = cs==checksums;
    dataLines = dataLines(iGoodChecksums);
    clear('cs');
    clear('checksums');
end
clear('allLines');

%dataLines = textscan(dataLines, 'Delimiter', ',');

splitData = split(dataLines, ',');
data.TIME = datenum([char(splitData(:,1)) char(splitData(:,2))],'ddmmyyyyHHMMSS.FFF');
comment.TIME = 'TIME';

switch instStr
    case 'IMNTU'
        for i=3:7
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
        
    case 'MS8EN'
        for i=3:12
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
        
        % PAR calculated
        % put all channel data into one array
        wavelengths = [425, 455, 485, 515, 555, 615, 660, 695];
        
        nChannels = length(wavelengths);
        nSamples = size(data.CH1,1);
        tmpData = zeros([nSamples, nChannels]);
        for i = 1:nChannels
            vName = ['CH' num2str(i)];
            tmpData(:,i)= data.(vName);
        end
        
        % Convert MS8EN/MS9 uW/cm^2/nm data to W/m^2/nm
        tmpData = tmpData ./ 100.0;
        PAR = calcPAR(tmpData, wavelengths);
        vName = 'PAR';
        data.(vName) = PAR.data;
        comment.(vName) = [PAR.comment ' For a typical solar spectrum the in-air MS8 derived PAR has an RMS error of 0.015%'] ;
        units.(vName) = PAR.units;
        
        if false
        % derive PAR from MS8EN sampled wavelengths using method from
        % Wojciech Klonowski @ Insitu Marine Optics
        lambda = [425, 455, 485, 515, 555, 615, 660, 695];
        nChannels = 8;
        % new spacing between 400 - 700 nm.
        newLambda = 400:1:700;
        nNewChannels = size(newLambda,2);
        nSamples = size(data.CH1,1);
        avo=6.022140857e+17; % Avogadro's constant * 1e6
        
        % Convert MS8EN data to W/m^2/nm
        tmpData = [data.CH1 data.CH2 data.CH3 data.CH4 data.CH5 data.CH6 data.CH7 data.CH8] / 100;

        % IMO: convert to photons per second by dividing by h*c / lambda. 
        % factor 1e-9 converts nm to m.
        h=6.626070040e-34; %plancks constant
        c=2.99792458e+08; %3.00e+08;
        tmpData = tmpData ./ ((h*c) ./ (lambda*1e-9));
        % IMO: convert to microMoles per second by dividing by 
        % Avogadro's constant * 1e6
        tmpData = tmpData / avo;
        
        % IMO: interpolate multispectral micromolespersec to high res 1nm
        % %IDL% micromolespersec_ipol=interpol(micromolespersec,lambda,new_lambda)
        newData=nan([nSamples, nNewChannels]);
        for i = 1:nSamples
            newData(i,:) = interp1(lambda, tmpData(i, :), newLambda, 'linear', 'extrap');
        end
        
        % IMO: now calculate the integral of micromolespersec_ipol. I would
        % think MATLAB has some sort of INT_TABULATED or Simpson or 
        % Trapezoidal functions.
        % %IDL% PAR=int_tabulated(new_lambda,micromolespersec_ipol)
        PAR = nan([nSamples, 1]);
        for i = 1:nSamples
            PAR(i) = trapz(newLambda, newData(i,:));
        end
        
        vName = 'PAR';
        vUnit = 'umole m-2 s-1';
        vComment = 'For a typical solar spectrum the in-air MS8 derived PAR has an RMS error of 0.015%';
        data.(vName) = PAR;
        comment.(vName) = vComment;
        units.(vName) = vUnit;
        end
        
    case 'IMO-DL3'
        for i=3:8
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
end

end

