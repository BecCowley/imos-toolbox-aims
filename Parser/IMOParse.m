function sample_data = IMOParse( filename, mode )
%IMOParse Parses a .log data file from an IMO sensor
%
% This function is able to read in a .log data file produced by extracting
% out sensor log from DL3 .text file.
%
%   - processed header  - header information generated by Logger Vue software.
%                         Typically first 5 lines.
%   - data              - Rows of comma seperated data.
%
% This function reads in the header sections, and delegates to the two file
% specific sub functions to process the data.
%
% Inputs:
%   filename    - cell array of files to import (only one supported).
%   mode        - Toolbox data type mode.
%
% Outputs:
%   sample_data - Struct containing sample data.
%
% Code based on SBE37SMParse.m
%
% Each data record starts with a Port Identifier. These Ports correspond
% to the Port numbering on the bulkhead connectors, with the exception
% of Port 0, which is reserved for the DL3’s additional internal sensor
% suite. Each data record contains the date (DD/MM/YYYY), time
% (HH:MM:SS:mil) and the external sensor’s data record encapsulated
% by ‘< >’ characters.
%
% The DL3 (Port 0) data format is as follows:
% Device Id, Serial Number, Vin Counts, Pressure Counts, Temp Counts, Vin
% (V), Depth (m), Temperature (C)
% example
% Port0: 07/04/2017,08:28:46.000,<IMO-DL3,0028,1023,3238,690,11.5,-0.3,28.4>
%
% IMO-NTU output:
% Sensor Type, Serial Number, Date, Time, dark_counts, measured_counts, NTU, tilt, led_temp, checksum
% Message ID $IMNTU
% Serial # 0012
% Date 21022016 ddmmyyyy
% Time 150327.000 hhmmss.sss
% Dark Counts 2122 Counts ADC Digital Counts (LED off)
% Meas Counts 2260 Counts ADC Digital Counts (LED on)
% NTU 1.796 NTU Calibrated NTU Output
% Tilt 66.3 Degrees ddd.d
% LED Temp 26.8125 Degrees Celsius xx.xxxx
% Checksum *7C
% example
% <$IMNTU,0031,30032017,115136.803,1997,1957,0.149,179.0,29.8125*7D>
%
% IMO-MS8
% NOTE: ONLY engineering/cal output MS8EN (output mode 1/cal), not MS8RW
% Sensor Type, Serial Number, Date, Time, (ch irradiance) x 8, Tilt, Int Temp
% PAR units: mW/cm^2
% example
% <$MS8EN,0026,27/03/2017,14:13:55.000,0.141,0.126,0.310,0.173,-0.019,0.048,0.030,0.063,86.8,27.625>
%
% The checksum field consists of a '*' and two hex digits representing
% an 8 bit exclusive OR of all characters between, but not including,
% the '$' and '*'.
%
% The sensor only .log format will only contain sensor data (without <>)
%
% Author:       Simon Spagnol <s.spagnol@aims.gov.au>
% Contributor:  Guillaume Galibert <guillaume.galibert@utas.edu.au>

%
% Copyright (c) 2017, Australian Ocean Data Network (AODN) and Integrated
% Marine Observing System (IMOS).
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%     * Redistributions of source code must retain the above copyright notice,
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the AODN/IMOS nor the names of its contributors
%       may be used to endorse or promote products derived from this software
%       without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%
narginchk(1,2);

if ~iscellstr(filename)
    error('filename must be a cell array of strings');
end

% only one file supported currently
filename = filename{1};

% read in every line of header in the file, then big read of data
procHeaderLines = {};
try
    fid = fopen(filename, 'rt');
    line = strtrim(fgetl(fid));
    frewind(fid);
    if strcmpi(line, 'In-situ Marine Optics')
        % most likely a .TXT format DL3 file
        [procHeader, data, comment] = readIMOdl3(fid);
    elseif strcmp(line(1), '$') || strfind(line, 'IMO-DL3')
        % most likely a .log format MS8/NTU/PAR file
        [procHeader, data, units, comment] = readIMOsensor(fid);
    else
        error('Unknown IMO format');
    end
    
    fclose(fid);
    
catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
end

procHeader.toolbox_input_file = filename;

% create sample data struct,
% and copy all the data in
sample_data = struct;

sample_data.toolbox_input_file  = filename;
sample_data.meta.featureType    = mode;
sample_data.meta.procHeader     = procHeader;

sample_data.meta.instrument_make = 'IMO';
if isfield(procHeader, 'instrument_model')
    sample_data.meta.instrument_model = procHeader.instrument_model;
else
    sample_data.meta.instrument_model = 'IMO Unknown';
end

if isfield(procHeader, 'instrument_firmware')
    sample_data.meta.instrument_firmware = procHeader.instrument_firmware;
else
    sample_data.meta.instrument_firmware = '';
end

if isfield(procHeader, 'instrument_serial_no')
    sample_data.meta.instrument_serial_no = procHeader.instrument_serial_no;
else
    sample_data.meta.instrument_serial_no = '';
end

time = data.TIME;

if isfield(procHeader, 'sampleInterval')
    sample_data.meta.instrument_sample_interval = procHeader.sampleInterval;
else
    sample_data.meta.instrument_sample_interval = median(diff(time*24*3600));
end

sample_data.dimensions = {};
sample_data.variables  = {};

% generate time data from header information
sample_data.dimensions{1}.name          = 'TIME';
sample_data.dimensions{1}.typeCastFunc  = str2func(netcdf3ToMatlabType(imosParameters(sample_data.dimensions{1}.name, 'type')));
sample_data.dimensions{1}.data          = sample_data.dimensions{1}.typeCastFunc(time);

sample_data.variables{end+1}.name           = 'TIMESERIES';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(1);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'LATITUDE';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'LONGITUDE';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];
sample_data.variables{end+1}.name           = 'NOMINAL_DEPTH';
sample_data.variables{end}.typeCastFunc     = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
sample_data.variables{end}.data             = sample_data.variables{end}.typeCastFunc(NaN);
sample_data.variables{end}.dimensions       = [];

% scan through the list of parameters that were read
% from the file, and create a variable for each
vars = fieldnames(data);
coordinates = 'TIME LATITUDE LONGITUDE NOMINAL_DEPTH';
for k = 1:length(vars)
    
    if strncmp('TIME', vars{k}, 4), continue; end
    
    % dimensions definition must stay in this order : T, Z, Y, X, others;
    % to be CF compliant
    sample_data.variables{end+1}.dimensions     = 1;
    sample_data.variables{end  }.name           = vars{k};
    sample_data.variables{end  }.typeCastFunc   = str2func(netcdf3ToMatlabType(imosParameters(sample_data.variables{end}.name, 'type')));
    sample_data.variables{end  }.data           = sample_data.variables{end}.typeCastFunc(data.(vars{k}));
    sample_data.variables{end  }.coordinates    = coordinates;
    sample_data.variables{end  }.comment        = comment.(vars{k});
    sample_data.variables{end  }.units        = units.(vars{k});
end

end

%%
function [header, data, comment] = readIMODL3(fid)
% parse IMO DL3 TXT file

% unlikely to be handled.

header = struct;
data = struct;
comment = struct;

error('IMO DL3 TXT format not handled.');

end

%%
function [header, data, units, comment] = readIMOsensor(fid)
% parse IMO sensor log file. Can only be one sensor per file.

header = struct;
data = struct;
comment = struct;
units = struct;

% IMO-MS8
% Sensor Type, Serial Number, Date, Time, Counts, PAR, Tilt, Int Temp
line = strtrim(fgetl(fid));
frewind(fid);

cols = split(line, ',');
nCols = numel(cols) - 4; % number of data columns
serialStr = char(cols(2));

instStr = '';
sensorVariableNames = {};
if strfind(line, '$IMNTU')
    instStr = 'IMNTU';
    formatStr = ['$' instStr];
    sensorVariableNames = {'DATE', 'TIME', 'COUNTS_DARK', 'COUNTS_NTU', 'TURB', 'TILT', 'LED_TEMP'};
    sensorVariableUnits = {'1', '1', 'count', 'count', '1', 'degree', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', ''};
    header.instrument_model = 'IMNTU';
elseif strfind(line, '$MS8EN')
    instStr = 'MS8EN';
    formatStr = ['$' instStr];
    sensorVariableNames = {'DATE', 'TIME', 'CH1', 'CH2', 'CH3', 'CH4', 'CH5', 'CH6', 'CH7', 'CH8','TILT', 'INTERNAL_TEMP'};
    sensorVariableUnits = {'1', '1', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'uW cm-2', 'degree', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', '' ,  '', '', '', '', ''};
    header.instrument_model = 'MS8EN';
elseif strfind(line, 'IMO-DL3')
    instStr = 'IMO-DL3';
    formatStr = instStr;
    %Device Id, Serial Number, Vin Counts, Pressure Counts, Temp Counts, Vin (V), Depth (m), Temperature (C)
    sensorVariableNames = {'DATE', 'TIME', 'COUNTS_VIN', 'COUNTS_PRES', 'COUNTS_TEMP', 'VIN', 'DEPTH', 'TEMP'};
    sensorVariableUnits = {'1', '1', 'count', 'count', 'count', 'V', 'm', 'degrees_Celsius'};
    sensorVariableComments = {'', '', '', '', '', '', '', ''};
    header.instrument_model = 'DL3';
else
    error('Uknown IMO sensor');
end

header.instrument_serial_no = char(cols(2));
formatStr = [formatStr ',%*d'];

iChecksum = strfind(line, '*');
if iChecksum
    formatStr = [formatStr ',%[^*]*%s'];
else
    formatStr = [formatStr ',%s'];
end

frewind(fid);
allLines = textscan(fid,formatStr);
dataLines = allLines{1};
if iChecksum
    checksums = uint8(hex2dec(allLines{2}));
    
    cs = zeros([numel(checksums) 1], 'uint8');
    for i=1:numel(checksums)
        line = [instStr ',' serialStr ',' char(dataLines{i})];
        for j = 1:length(line)
            cs(i) = bitxor(cs(i), uint8(line(j)));
        end
    end
    iGoodChecksums = cs==checksums;
    dataLines = dataLines(iGoodChecksums);
    clear('cs');
    clear('checksums');
end
clear('allLines');

%dataLines = textscan(dataLines, 'Delimiter', ',');

splitData = split(dataLines, ',');
data.TIME = datenum([char(splitData(:,1)) char(splitData(:,2))],'ddmmyyyyHHMMSS.FFF');
comment.TIME = 'TIME';

switch instStr
    case 'IMNTU'
        for i=3:7
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
        
    case 'MS8EN'
        for i=3:12
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
        % derive PAR from MS8EN sampled wavelengths using method from
        % Wojciech Klonowski @ Insitu Marine Optics
        lambda = [425, 455, 485, 515, 555, 615, 660, 695];
        nChannels = 8;
        % new spacing between 400 - 700 nm.
        newLambda = 400:1:700;
        nNewChannels = size(newLambda,2);
        nSamples = size(data.CH1,1);
        avo=6.022140857e+17; % Avogadro's constant * 1e6
        
        % Convert MS8EN data to W/m^2/nm
        tmpData = [data.CH1 data.CH2 data.CH3 data.CH4 data.CH5 data.CH6 data.CH7 data.CH8] / 100;

        % IMO: convert to photons per second by dividing by h*c / lambda. 
        % factor 1e-9 converts nm to m.
        h=6.626070040e-34; %plancks constant
        c=2.99792458e+08; %3.00e+08;
        tmpData = tmpData ./ ((h*c) ./ (lambda*1e-9));
        % IMO: convert to microMoles per second by dividing by 
        % Avogadro's constant * 1e6
        tmpData = tmpData / avo;
        
        % IMO: interpolate multispectral micromolespersec to high res 1nm
        % %IDL% micromolespersec_ipol=interpol(micromolespersec,lambda,new_lambda)
        newData=nan([nSamples, nNewChannels]);
        for i = 1:nSamples
            newData(i,:) = interp1(lambda, tmpData(i, :), newLambda, 'linear', 'extrap');
        end
        
        % IMO: now calculate the integral of micromolespersec_ipol. I would
        % think MATLAB has some sort of INT_TABULATED or Simpson or 
        % Trapezoidal functions.
        % %IDL% PAR=int_tabulated(new_lambda,micromolespersec_ipol)
        PAR = nan([nSamples, 1]);
        for i = 1:nSamples
            PAR(i) = trapz(newLambda, newData(i,:));
        end
        
        vName = 'PAR';
        vUnit = 'umole m-2 s-1';
        vComment = 'For a typical solar spectrum the MS8 derived PAR has an RMS error of 0.015%';
        data.(vName) = PAR;
        comment.(vName) = vComment;
        units.(vName) = vUnit;
        
    case 'IMO-DL3'
        for i=3:8
            vName = char(sensorVariableNames{i});
            vUnit = char(sensorVariableUnits{i});
            vComment = char(sensorVariableComments{i});
            data.(vName) = str2double(splitData(:,i));
            comment.(vName) = vComment;
            units.(vName) = vUnit;
        end
end

end

